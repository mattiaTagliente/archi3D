## Role

Implement **Phase 9 — Typed SSOT Schemas, Validation, and Developer Scaffolding**. You will add **strongly-typed models**, a **central schema registry**, **validators**, and **developer self-tests** for the two SSOT tables:

* `tables/items.csv` (parents) — defined in Phase 1, including ordering and path rules. 
* `tables/generations.csv` (children/jobs) — initialized in Phase 2, enriched by Phases 3, 5, 6; consolidation/reporting rely on it unchanged.

**Do not** change CLI behavior, CSV schemas, thresholds, or adapter semantics from Phases 0–8. Reuse the **PathResolver** and **atomic I/O** utilities from Phase 0. 

---

## Objectives

1. **Typed row models** for both SSOT tables using Pydantic (already in repo):

   * `ItemRow` for `items.csv` (Phase-1 columns, order preserved). 
   * `GenerationRowCore` (Phase-2 carry-overs + batch/job fields), `GenerationRowFScore` (Phase-5 fields), `GenerationRowVFScore` (Phase-6 fields), and a **composed** `GenerationRow` union model.
2. **Schema registry** that encodes **canonical column order** and types for:
   `items.csv`, `generations(core)`, `generations(+fscore)`, `generations(+vfscore)`, `generations(all)`.
   (No renames; strictly the column names from Phases 1/2/5/6 in the specified order.)
3. **Validators** and **helpers** to:

   * Load/validate CSVs, **coerce types**, ensure **workspace-relative** paths, and check **key uniqueness** (`(product_id,variant)` for items; `(run_id,job_id)` for generations).
   * Detect **schema drift** (unknown/missing columns) and report **non-blocking warnings** unless strict mode.
4. **Dev scaffolding & self-tests:**

   * A single script to run end-to-end **schema checks** on a workspace and generate a compact **SCHEMA.md** from the registry.
   * Tiny **fixtures** to exercise parsing, coercion, path normalization, and key uniqueness.
5. **Zero behavioral change** for existing commands (Phases 0–8): the new code is **imported by** but does **not modify** current CLI flows.

---

## Non-Goals

* No new CLI flags or commands.
* No writes to SSOT other than optional **docs export (SCHEMA.md)**.
* No schema changes; you only **codify** the current schemas and validate instances.
* No new third-party deps beyond what the repo already uses (Pydantic, pandas, filelock). 

---

## Repository Pointers (what/where to add)

* `src/archi3d/db/schema_registry.py` **(new)** — canonical ordered column lists, types, and small descriptions.
* `src/archi3d/db/models.py` **(new)** — Pydantic models: `ItemRow`, `GenerationRowCore`, `GenerationRowFScore`, `GenerationRowVFScore`, `GenerationRow`.
* `src/archi3d/db/validators.py` **(new)** — CSV load/validate/coerce helpers (+ path normalization).
* `scripts/dev/phase9_selftest.py` **(new)** — standalone developer self-test.
* `docs/SCHEMA.md` **(generated by the script)** — human-readable schema doc.
* Reuse Phase-0 utilities and paths (no duplication): `PathResolver`, `update_csv_atomic`, `append_log_record`, `write_text_atomic`. 

---

## Functional Requirements

#### A) Schema Registry (ordered, canonical)

Create `schema_registry.py` with:

1. **Items (Phase-1 order)** — **exact column names**:
   `["product_id","variant","manufacturer","product_name","category_l1","category_l2","category_l3","description","n_images","image_1_path","image_2_path","image_3_path","image_4_path","image_5_path","image_6_path","gt_object_path","dataset_dir","build_time","source_json_present"]` (+ type hints). 

2. **Generations (Phase-2 core order)**: carry-overs, then batch/job metadata exactly as specified in Phase 2. 

3. **FScore extension (Phase-5)**: add Phase-5 metric fields in the exact names/order listed (fscore, precision, recall, chamfer_l2, fscore_n_points, alignment & dist stats columns, runtime/version/config, status/error). 

4. **VFScore extension (Phase-6)**: add Phase-6 visual metrics and provenance fields exactly as listed (overall, subscores, repeats/dispersion, model/rubric, runtimes, config hash, rationales dir, status/error). 

Expose utilities:

* `columns_items()`, `columns_generations_core()`, `columns_generations_all()`
* `types_items()`, `types_generations()` (pandas dtypes / Python types)
* `describe_columns(table)` returning a list of `(name, type, description)` for docs generation.

#### B) Typed Models (Pydantic)

In `models.py`, define:

* `class ItemRow(BaseModel)` — fields and defaults matching **Phase-1** schema; nullable where Phase-1 allows blanks; `n_images: int` with `ge=0, le=6`. Enforce `product_id: str`, `variant: str="default"`. 
* `class GenerationRowCore(BaseModel)` — fields from **Phase-2** (carry-overs + batch/job metadata), with `run_id` & `job_id` required; `status` constrained to allowed values. 
* `class GenerationRowFScore(BaseModel)` — Phase-5 fields (all optional). 
* `class GenerationRowVFScore(BaseModel)` — Phase-6 fields (all optional). 
* `class GenerationRow(GenerationRowCore, GenerationRowFScore, GenerationRowVFScore)` — composed view.

**Validators (Pydantic `@field_validator` or `model_validator`):**

* Paths must be **workspace-relative** (no absolute, no drive letter); may be empty if legitimately missing. (Phases 0–6 enforce relativity.) 
* `used_n_images` must equal non-empty count in `used_image_*` columns; similarly `source_n_images` vs `source_image_*`. (Phase-2 invariant.) 
* If `fscore_status=="ok"` then require the Phase-5 core numeric fields present; analogous for `vf_status=="ok"`.

#### C) CSV Load/Validate/Coerce Helpers

In `validators.py`:

* `load_items_csv(resolver: PathResolver) -> pd.DataFrame`
* `load_generations_csv(resolver: PathResolver) -> pd.DataFrame`

Both must:

1. Read CSV with UTF-8-SIG; **do not** reorder columns; keep unknown extra columns (tolerant). (Phase-0 CSV rules.) 
2. **Coerce** types according to the registry (e.g., timestamps to string ISO, numerics to float/int with NaN allowed where prior phases permit), leaving uncoercibles as NaN/empty and **collecting warnings**.
3. **Check keys**: unique `(product_id,variant)` for items; unique `(run_id,job_id)` for generations; report duplicates list.
4. **Path checks** (relative to `workspace`): verify the string shape; **do not** hit filesystem (Phase-9 is schema-level).
5. Provide `strict: bool=False` to raise on: missing required columns, duplicate keys, or disallowed absolute paths.
6. Provide `summarize(df, table)` returning small dict: row count, missing/extra columns, duplicate count, numeric null stats for core KPI columns (fscore, vfscore_overall, durations, etc.).

#### D) SCHEMA.md Generator

Add `scripts/dev/phase9_selftest.py`:

* **Mode A (default)**: run in current workspace; load both CSVs via `PathResolver`; print **PASS/FAIL** summary for:

  * required columns present, key uniqueness, path relativity invariants, Phase-5/6 consistency when statuses are `ok`.
* **Mode B (`--export-schema`)**: write `docs/SCHEMA.md` containing:

  * Sections for **Items** and **Generations** with ordered tables of columns (name, type, short description, introduced-in-phase). Sources for each list point to Phase-1/2/5/6.
* Use Phase-0 `write_text_atomic` to write docs. 

#### E) Integration & Safety

* **No CLI changes**; modules are imported by existing phases where useful (e.g., reporting can optionally import the registry to format tables), but **do not alter** runtime behavior. 
* Respect Phase-0 encoding (UTF-8-SIG) and never write partials. 

---

## Acceptance Criteria (Definition of Done)

1. **Schema Registry** exposes ordered column lists for items and generations (core / +fscore / +vfscore / all), exactly matching Phases 1/2/5/6 names and order.
2. **Models** validate single rows with the constraints above (paths relative, image counts consistent, statuses imply required fields).
3. **Validators** load both CSVs, coerce types, detect duplicates, and produce warnings; `strict=True` raises on schema/key violations.
4. **Self-test script** runs end-to-end on a dev workspace; `--export-schema` generates `docs/SCHEMA.md`.
5. **No regressions**: Phases 0–8 commands run unchanged; no CSV writes occur from Phase-9 code except SCHEMA.md generation.

---

## Minimal Tests / Self-Tests

Place in `scripts/dev/phase9_selftest.py`:

* **Test 1 — Items schema OK:** craft a tiny temp workspace with a valid `items.csv` row; assert `strict=True` passes. (Order and path relativity enforced.) 
* **Test 2 — Generations core + metrics:** synthetic `generations.csv` with one completed job including Phase-5 and Phase-6 columns; assert validators pass and KPI null stats computed.
* **Test 3 — Duplicate keys:** inject duplicate `(run_id,job_id)`; expect failure in strict mode and warnings in non-strict.
* **Test 4 — Absolute path violation:** put an absolute `gen_object_path`; expect strict failure and non-strict warning.
* **Test 5 — SCHEMA.md:** run `--export-schema` and assert file exists and lists columns in canonical order.

---

## Deliverables

* **New:**
  `src/archi3d/db/schema_registry.py`
  `src/archi3d/db/models.py`
  `src/archi3d/db/validators.py`
  `scripts/dev/phase9_selftest.py`
* **Generated:**
  `docs/SCHEMA.md` (by self-test script)
* **No changes** to existing CLI modules; optional import hooks only.

---

## Implementation Notes

* Use `PathResolver` from Phase-0 for workspace and **do not** read dataset or run trees here. 
* Keep descriptions short; cite “Introduced in Phase-X” per column group in the registry source comments.
* Prefer permissive parsing with precise error messaging; make `strict=True` suitable for CI.
* Maintain cross-platform path checks (Windows/POSIX); store/expect POSIX-like separators in CSV as per Phase-1 guidance. 

---

By completing **Phase 9** as specified, the project gains **explicit, code-level schemas** for both SSOT tables, reliable **validation utilities**, and **developer docs**—all without changing Phase 0–8 behaviors. This reduces drift, improves auditability for Phase 7 reporting and Phase 8 adapters, and hardens the pipeline’s long-term maintainability. 

---
## 📝 IMPORTANT: Update Documentation

**After completing this phase, you MUST update the project documentation:**

1. Update `CLAUDE.md` with:
   - New functionality added in this phase
   - Usage examples and patterns
   - Any new constraints or design patterns
   - Update the "Implementation Status" section with phase completion details

2. Keep documentation comprehensive and consolidated (avoid creating many small files)

3. The user prefers documentation that retains all information in a few comprehensive files

**This is a critical step - do not consider the phase complete until documentation is updated!**

---
